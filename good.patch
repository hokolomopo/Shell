diff --git a/arch/x86/entry/syscalls/syscall_32.tbl b/arch/x86/entry/syscalls/syscall_32.tbl
index e62f440..9545ad7 100644
--- a/arch/x86/entry/syscalls/syscall_32.tbl
+++ b/arch/x86/entry/syscalls/syscall_32.tbl
@@ -383,3 +383,6 @@
 374	i386	userfaultfd		sys_userfaultfd
 375	i386	membarrier		sys_membarrier
 376	i386	mlock2			sys_mlock2
+377 i386  pfstat    sys_pfstat
+378 i386 lock_fs    sys_lock_fs
+379 i386 fat_change_password    sys_fat_change_password
diff --git a/fs/fat/dir.c b/fs/fat/dir.c
index 8b2127f..b50f261 100644
--- a/fs/fat/dir.c
+++ b/fs/fat/dir.c
@@ -476,6 +476,7 @@ int fat_search_long(struct inode *inode, const unsigned char *name,
 	while (1) {
 		if (fat_get_entry(inode, &cpos, &bh, &de) == -1)
 			goto end_of_dir;
+
 parse_record:
 		nr_slots = 0;
 		if (de->name[0] == DELETED_FLAG)
@@ -588,6 +589,7 @@ static int __fat_readdir(struct inode *inode, struct file *file,
 get_new:
 	if (fat_get_entry(inode, &cpos, &bh, &de) == -1)
 		goto end_of_dir;
+
 parse_record:
 	nr_slots = 0;
 	/*
@@ -647,6 +649,7 @@ parse_record:
 	}
 
 	short_len = fat_parse_short(sb, de, bufname, sbi->options.dotsOK);
+
 	if (short_len == 0)
 		goto record_end;
 
@@ -654,6 +657,12 @@ parse_record:
 	fill_len = short_len;
 
 start_filldir:
+
+	//VFAT_PATCH
+	if(!sbi->lock_mode && (de->attr & ATTR_VFATHIDDEN)){
+		goto record_end;
+	}
+
 	ctx->pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);
 	if (fake_offset && ctx->pos < 2)
 		ctx->pos = 2;
@@ -956,6 +965,8 @@ int fat_scan(struct inode *dir, const unsigned char *name,
 {
 	struct super_block *sb = dir->i_sb;
 
+	printk("fat : scan\n");
+
 	sinfo->slot_off = 0;
 	sinfo->bh = NULL;
 	while (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,
diff --git a/fs/fat/fat.h b/fs/fat/fat.h
index be5e153..24ca942 100644
--- a/fs/fat/fat.h
+++ b/fs/fat/fat.h
@@ -23,6 +23,9 @@
 #define FAT_NFS_STALE_RW	1      /* NFS RW support, can cause ESTALE */
 #define FAT_NFS_NOSTALE_RO	2      /* NFS RO support, no ESTALE issue */
 
+//VFAT_PATCH
+#define FAT_PASSWORD_START 127
+
 struct fat_mount_options {
 	kuid_t fs_uid;
 	kgid_t fs_gid;
@@ -101,6 +104,10 @@ struct msdos_sb_info {
 
 	unsigned int dirty;           /* fs state before mount */
 	struct rcu_head rcu;
+
+	//VFAT_PATCH
+	 int lock_mode;
+	 char passwd[8];
 };
 
 #define FAT_CACHE_VALID	0	/* special case for valid cache */
diff --git a/fs/fat/file.c b/fs/fat/file.c
index a08f103..a7ee860 100644
--- a/fs/fat/file.c
+++ b/fs/fat/file.c
@@ -45,6 +45,14 @@ static int fat_ioctl_set_attributes(struct file *file, u32 __user *user_attr)
 		goto out;
 	mutex_lock(&inode->i_mutex);
 
+	//VFAT_PATCH
+	if(!sbi->lock_mode){
+		attr &= ~ATTR_VFATHIDDEN;
+	}
+	if(!sbi->lock_mode && ((MSDOS_I(inode)->i_attrs & ATTR_VFATHIDDEN))){
+		attr |= ATTR_VFATHIDDEN;
+	}
+
 	/*
 	 * ATTR_VOLUME and ATTR_DIR cannot be changed; this also
 	 * prevents the user from turning us into a VFAT
@@ -164,8 +172,20 @@ int fat_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)
 	return res ? res : err;
 }
 
+//VFAT_PATCH
+ssize_t
+vfat_open(struct inode *inode, struct file *file){
+	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
+
+	if(!sbi->lock_mode && (MSDOS_I(inode)->i_attrs & ATTR_VFATHIDDEN)){
+		return -ENOENT;
+	}
+
+	return 0;
+}
 
 const struct file_operations fat_file_operations = {
+	.open    = vfat_open,
 	.llseek		= generic_file_llseek,
 	.read_iter	= generic_file_read_iter,
 	.write_iter	= generic_file_write_iter,
diff --git a/fs/fat/inode.c b/fs/fat/inode.c
index 509411d..938040e 100644
--- a/fs/fat/inode.c
+++ b/fs/fat/inode.c
@@ -22,6 +22,13 @@
 #include <asm/unaligned.h>
 #include "fat.h"
 
+#include <linux/syscalls.h>
+#include <linux/namei.h>
+
+#ifndef ISVFAT
+# define ISVFAT(a)	((a[0] == 'v') && (a[1] == 'f') && (a[2] == 'a') && (a[3] == 't'))
+#endif
+
 #ifndef CONFIG_FAT_DEFAULT_IOCHARSET
 /* if user don't select VFAT, this is undefined. */
 #define CONFIG_FAT_DEFAULT_IOCHARSET	""
@@ -1496,6 +1503,7 @@ int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,
 	int debug;
 	long error;
 	char buf[50];
+	char* fat_password;
 
 	/*
 	 * GFP_KERNEL is ok here, because while we do hold the
@@ -1535,6 +1543,19 @@ int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,
 	if (error == -EINVAL && sbi->options.dos1xfloppy)
 		error = fat_read_static_bpb(sb,
 			(struct fat_boot_sector *)bh->b_data, silent, &bpb);
+
+	//VFAT_PATCH
+	sbi->lock_mode = 0;
+	fat_password = ((struct fat_boot_sector *)bh->b_data)->system_id;
+	if(fat_password[0] != FAT_PASSWORD_START){
+		fat_password[0] = FAT_PASSWORD_START;
+		fat_password[1] = '\0';
+		mark_buffer_dirty(bh);
+		sync_dirty_buffer(bh);
+	}
+	memcpy(sbi->passwd, fat_password, 8);
+
+
 	brelse(bh);
 
 	if (error == -EINVAL)
@@ -1545,6 +1566,9 @@ int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,
 	logical_sector_size = bpb.fat_sector_size;
 	sbi->sec_per_clus = bpb.fat_sec_per_clus;
 
+
+
+
 	error = -EIO;
 	if (logical_sector_size < sb->s_blocksize) {
 		fat_msg(sb, KERN_ERR, "logical sector size too small for device"
@@ -1849,3 +1873,130 @@ module_init(init_fat_fs)
 module_exit(exit_fat_fs)
 
 MODULE_LICENSE("GPL");
+
+//VFAT_PATCH
+SYSCALL_DEFINE3(lock_fs, char*, u_fs, char*, u_paswd, int, mode){
+	struct super_block* sb;
+	struct file* f;
+	int i = 0, err = 0;
+	struct msdos_sb_info *sbi;
+	char fs[500], in_passwd[7];
+
+	if(copy_from_user(fs, u_fs, 500)){
+		err = -EFAULT;
+		goto out;
+	}
+
+	if(mode == 1 && copy_from_user(in_passwd, u_paswd, 7)){
+		err = -EFAULT;
+		goto out;
+	}
+
+	f = filp_open(fs, O_RDONLY, 0);
+	if(IS_ERR(f)){
+		err = -ENOENT;
+		goto out;
+	}
+
+	sb = f->f_inode->i_sb;
+	sbi = sb->s_fs_info;
+
+	if(!ISVFAT(sb->s_type->name)){
+		err = -EBADF;
+		goto out;
+	}
+
+	mutex_lock(&sbi->s_lock);
+
+	//Lock the FS
+	if(mode == 0){
+		sbi->lock_mode = 0;
+		goto close;
+	}
+
+	//If we're already on unlocked mode goto end
+	if(sbi->lock_mode == 1)
+		goto close;
+
+	for(i = 0; in_passwd[i] != '\0' && i < 7;i++){
+		if(sbi->passwd[i+1] != in_passwd[i]){
+			err = -EINVAL;
+			goto close;
+		}
+	}
+
+	sbi->lock_mode = 1;
+
+close:
+	mutex_unlock(&sbi->s_lock);
+	filp_close(f, NULL);
+out :
+	return err;
+}
+
+
+SYSCALL_DEFINE3(fat_change_password, char*, u_new, char*, u_old, char*, u_fs){
+	struct fat_boot_sector* fbs;
+	struct buffer_head *bh;
+	struct super_block* sb;
+	struct file* f;
+	int i = 0, err = 0;
+	struct msdos_sb_info *sbi;
+	char old[7], new[7], fs[500];
+
+
+	if(copy_from_user(fs, u_fs, 500)){
+		err = -EFAULT;
+		goto out;
+	}
+
+	if(copy_from_user(new, u_new, 7) || copy_from_user(old, u_old, 7)){
+		err = -EFAULT;
+		goto out;
+	}
+
+	f = filp_open(fs, O_RDONLY, 0);
+	if(IS_ERR(f)){
+		err = -ENOENT;
+		goto out;
+	}
+
+	sb = f->f_inode->i_sb;
+	sbi = sb->s_fs_info;
+
+	mutex_lock(&sbi->s_lock);
+
+	if(!ISVFAT(sb->s_type->name)){
+		err = -EBADF;
+		goto close;
+	}
+
+	for(i = 0; sbi->passwd[i] != '\0' && i < 7;i++){
+		if(sbi->passwd[i+1] != old[i]){
+			err = -EINVAL;
+			goto close;
+		}
+	}
+
+	bh = sb_bread(sb, 0);
+	if(bh == NULL){
+		err = -EIO;
+		goto close;
+	}
+	fbs = (struct fat_boot_sector*)bh->b_data;
+
+	for(i = 1;i < 8;i++){
+		fbs->system_id[i] = new[i-1];
+		sbi->passwd[i] = new[i-1];
+	}
+
+	mark_buffer_dirty(bh);
+	sync_dirty_buffer(bh);
+
+	brelse(bh);
+close :
+	mutex_unlock(&sbi->s_lock);
+	filp_close(f, NULL);
+out :
+	return err;
+}
diff --git a/include/linux/init_task.h b/include/linux/init_task.h
index 1c1ff7e..fa6c785 100644
--- a/include/linux/init_task.h
+++ b/include/linux/init_task.h
@@ -191,6 +191,7 @@ extern struct task_group root_task_group;
 {									\
 	.state		= 0,						\
 	.stack		= &init_thread_info,				\
+	.pfstats    = NULL,				\
 	.usage		= ATOMIC_INIT(2),				\
 	.flags		= PF_KTHREAD,					\
 	.prio		= MAX_PRIO-20,					\
diff --git a/include/linux/pfstat.h b/include/linux/pfstat.h
new file mode 100644
index 0000000..81aeb35
--- /dev/null
+++ b/include/linux/pfstat.h
@@ -0,0 +1,27 @@
+#ifndef PFSTAT
+#define PFSTAT
+
+
+enum pfstat_field{
+  PFSTSAT_STACK_LOW,
+  PFSTSAT_TRANSPARENT_HUGEMAGE,
+  PFSTSAT_ANONYMOUS_FAULT,
+  PFSTSAT_FILE_FAULT,
+  PFSTSAT_SWAPPED_BACK,
+  PFSTSAT_COW,
+  PFSTSAT_ALLOCED_PAGES
+};
+
+struct pfstat {
+	int stack_low; //Number of times the stack was expanded after a page fault
+	int transparent_hugepage_fault; //Number of huge page transparent PMD fault
+	int anonymous_fault; //Normal anonymous page fault
+	int file_fault; //Normal file-backed page fault
+	int swapped_back; //Number of fault that produced a read-from swap to put
+	int copy_on_write; //Number of fault which backed a copy-on-write;
+	int fault_alloced_page; //Number of normal pages allocated due to a page
+};
+
+void update_pfstat(enum pfstat_field field);
+
+#endif /* PFSTAT */
diff --git a/include/linux/sched.h b/include/linux/sched.h
index ce0f61d..c690a7f 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -62,6 +62,8 @@ struct sched_param {
 
 #include <asm/processor.h>
 
+#include <linux/pfstat.h>
+
 #define SCHED_ATTR_SIZE_VER0	48	/* sizeof first published struct */
 
 /*
@@ -1384,6 +1386,8 @@ struct task_struct {
 	unsigned int flags;	/* per process flags, defined below */
 	unsigned int ptrace;
 
+	struct pfstat *pfstats;
+
 #ifdef CONFIG_SMP
 	struct llist_node wake_entry;
 	int on_cpu;
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index c2b66a2..55531fe 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -889,4 +889,11 @@ asmlinkage long sys_membarrier(int cmd, int flags);
 
 asmlinkage long sys_mlock2(unsigned long start, size_t len, int flags);
 
+asmlinkage long sys_pfstat(pid_t pid, struct pfstat* pfstats);
+
+asmlinkage long sys_lock_fs(char* fs, char* u_paswd, int mode);//VFAT_PATCH
+asmlinkage long sys_fat_change_password(char* u_new, char* u_old, char* u_fs);
+
+
+
 #endif
diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index e956704..85e233a 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -37,9 +37,10 @@
 #define ATTR_VOLUME	8	/* volume label */
 #define ATTR_DIR	16	/* directory */
 #define ATTR_ARCH	32	/* archived */
+#define ATTR_VFATHIDDEN 64 //VFAT_PATCH
 
 /* attribute bits that are copied "as is" */
-#define ATTR_UNUSED	(ATTR_VOLUME | ATTR_ARCH | ATTR_SYS | ATTR_HIDDEN)
+#define ATTR_UNUSED	(ATTR_VOLUME | ATTR_ARCH | ATTR_SYS | ATTR_HIDDEN | ATTR_VFATHIDDEN)
 /* bits that are used by the Windows 95/Windows NT extended FAT */
 #define ATTR_EXT	(ATTR_RO | ATTR_HIDDEN | ATTR_SYS | ATTR_VOLUME)
 
diff --git a/kernel/exit.c b/kernel/exit.c
index ffba5df..53dd80a 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -738,6 +738,8 @@ void do_exit(long code)
 		acct_process();
 	trace_sched_process_exit(tsk);
 
+	kfree(tsk->pfstats);
+
 	exit_sem(tsk);
 	exit_shm(tsk);
 	exit_files(tsk);
diff --git a/kernel/fork.c b/kernel/fork.c
index 2e55b53..0b4ecc2 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1424,6 +1424,8 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 #endif
 
 	p->pagefault_disabled = 0;
+	p->pfstats = NULL;
+
 
 #ifdef CONFIG_LOCKDEP
 	p->lockdep_depth = 0; /* no locks held yet */
diff --git a/kernel/sys.c b/kernel/sys.c
index 78947de..c95f515 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -57,6 +57,8 @@
 /* Move somewhere else to avoid recompiling? */
 #include <generated/utsrelease.h>
 
+#include <linux/pfstat.h>
+
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unistd.h>
@@ -2429,3 +2431,76 @@ COMPAT_SYSCALL_DEFINE1(sysinfo, struct compat_sysinfo __user *, info)
 	return 0;
 }
 #endif /* CONFIG_COMPAT */
+
+SYSCALL_DEFINE2(pfstat, pid_t, pid, struct pfstat*, usr_stats){
+	struct task_struct* task;
+
+	printk("[PFSTAT] Syscall entered! \n");
+
+	task = find_task_by_vpid(pid);
+
+	if(!task){
+		printk("[PFSTAT] Error : Not valid PID\n");
+		return 1;
+	}
+
+	//Init pfstat struct
+	if(!task->pfstats){
+		printk("[PFSTAT] Process %s is now in PFSTAT mode\n", task->comm);
+
+		task->pfstats = (struct pfstat*)(kmalloc(sizeof(struct pfstat), GFP_KERNEL));
+		if(!task->pfstats){
+			printk("[PFSTAT] Error :Error allocing the kernel struct \n");
+			return 3;
+		}
+	}
+	//Return stats
+	else{
+		if(copy_to_user(usr_stats, task->pfstats, sizeof(struct pfstat)) != 0){
+			printk("[PFSTAT] Error : Pointer not valid\n");
+			return 2;
+		}
+	}
+
+	task->pfstats->stack_low = 0;
+	task->pfstats->transparent_hugepage_fault = 0;
+	task->pfstats->anonymous_fault = 0;
+	task->pfstats->file_fault = 0;
+	task->pfstats->swapped_back = 0;
+	task->pfstats->copy_on_write = 0;
+	task->pfstats->fault_alloced_page = 0;
+
+	return 0;
+}
+
+void update_pfstat(enum pfstat_field field){
+
+	if(!current->pfstats)
+		return;
+
+	printk("update pfstat \n");
+
+	switch(field){
+		case PFSTSAT_STACK_LOW :
+			current->pfstats->stack_low++;
+			break;
+		case PFSTSAT_TRANSPARENT_HUGEMAGE :
+			current->pfstats->transparent_hugepage_fault++;
+			break;
+		case PFSTSAT_ANONYMOUS_FAULT :
+			current->pfstats->anonymous_fault++;
+			break;
+		case PFSTSAT_FILE_FAULT :
+			current->pfstats->file_fault++;
+			break;
+		case PFSTSAT_SWAPPED_BACK :
+			current->pfstats->swapped_back++;
+			break;
+		case PFSTSAT_COW :
+			current->pfstats->copy_on_write++;
+			break;
+		case PFSTSAT_ALLOCED_PAGES :
+			current->pfstats->fault_alloced_page++;
+			break;
+	}
+}
diff --git a/mm/memory.c b/mm/memory.c
index 76dcee3..d13b607 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2213,6 +2213,9 @@ static int wp_page_copy(struct mm_struct *mm, struct vm_area_struct *vma,
 		}
 		page_cache_release(old_page);
 	}
+
+	update_pfstat(PFSTSAT_COW);
+
 	return page_copied ? VM_FAULT_WRITE : 0;
 oom_free_new:
 	page_cache_release(new_page);
@@ -2496,6 +2499,8 @@ static int do_swap_page(struct mm_struct *mm, struct vm_area_struct *vma,
 	int exclusive = 0;
 	int ret = 0;
 
+	update_pfstat(PFSTSAT_SWAPPED_BACK);
+
 	if (!pte_unmap_same(mm, pmd, page_table, orig_pte))
 		goto out;
 
@@ -2711,6 +2716,8 @@ static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 
 	pte_unmap(page_table);
 
+	update_pfstat(PFSTSAT_ANONYMOUS_FAULT);
+
 	/* File mapping without ->vm_ops ? */
 	if (vma->vm_flags & VM_SHARED)
 		return VM_FAULT_SIGBUS;
@@ -3155,9 +3162,12 @@ static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 		unsigned long address, pte_t *page_table, pmd_t *pmd,
 		unsigned int flags, pte_t orig_pte)
 {
+
 	pgoff_t pgoff = (((address & PAGE_MASK)
 			- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 
+	update_pfstat(PFSTSAT_FILE_FAULT);
+
 	pte_unmap(page_table);
 	/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */
 	if (!vma->vm_ops->fault)
@@ -3275,6 +3285,8 @@ out:
 static int create_huge_pmd(struct mm_struct *mm, struct vm_area_struct *vma,
 			unsigned long address, pmd_t *pmd, unsigned int flags)
 {
+	update_pfstat(PFSTSAT_TRANSPARENT_HUGEMAGE);
+
 	if (vma_is_anonymous(vma))
 		return do_huge_pmd_anonymous_page(mm, vma, address, pmd, flags);
 	if (vma->vm_ops->pmd_fault)
@@ -3394,6 +3406,9 @@ static int __handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 	pmd = pmd_alloc(mm, pud, address);
 	if (!pmd)
 		return VM_FAULT_OOM;
+
+		update_pfstat(PFSTSAT_ALLOCED_PAGES);
+
 	if (pmd_none(*pmd) && transparent_hugepage_enabled(vma)) {
 		int ret = create_huge_pmd(mm, vma, address, pmd, flags);
 		if (!(ret & VM_FAULT_FALLBACK))
diff --git a/mm/mmap.c b/mm/mmap.c
index 455772a..500f3ad 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2216,6 +2216,9 @@ int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 	anon_vma_unlock_write(vma->anon_vma);
 	khugepaged_enter_vma_merge(vma, vma->vm_flags);
 	validate_mm(mm);
+
+	update_pfstat(PFSTSAT_STACK_LOW);
+
 	return error;
 }
 #endif /* CONFIG_STACK_GROWSUP || CONFIG_IA64 */
@@ -2286,6 +2289,9 @@ int expand_downwards(struct vm_area_struct *vma,
 	anon_vma_unlock_write(vma->anon_vma);
 	khugepaged_enter_vma_merge(vma, vma->vm_flags);
 	validate_mm(mm);
+
+	update_pfstat(PFSTSAT_STACK_LOW);
+
 	return error;
 }
 
